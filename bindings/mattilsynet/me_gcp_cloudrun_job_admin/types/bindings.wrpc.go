// Generated by `wit-bindgen-wrpc-go` 0.11.0. DO NOT EDIT!
package types

import (
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	wrpc "wrpc.io/go"
)

type ManagedEnvironmentGcpManifest struct {
	Bytes []uint8
}

func (v *ManagedEnvironmentGcpManifest) String() string { return "ManagedEnvironmentGcpManifest" }

func (v *ManagedEnvironmentGcpManifest) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)
	slog.Debug("writing field", "name", "bytes")
	write0, err := func(v []uint8, w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing list length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
		}
		slog.Debug("writing list elements")
		writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
		for i, e := range v {
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
				slog.Debug("writing u8 byte")
				return w.WriteByte(v)
			}(e, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
			}
			if write != nil {
				writes[uint32(i)] = write
			}
		}
		if len(writes) > 0 {
			return func(w wrpc.IndexWriter) error {
				var wg sync.WaitGroup
				var wgErr atomic.Value
				for index, write := range writes {
					wg.Add(1)
					w, err := w.Index(index)
					if err != nil {
						return fmt.Errorf("failed to index nested list writer: %w", err)
					}
					write := write
					go func() {
						defer wg.Done()
						if err := write(w); err != nil {
							wgErr.Store(err)
						}
					}()
				}
				wg.Wait()
				err := wgErr.Load()
				if err == nil {
					return nil
				}
				return err.(error)
			}, nil
		}
		return nil, nil
	}(v.Bytes, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `bytes` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

type ErrorType struct {
	payload      any
	discriminant ErrorTypeDiscriminant
}

func (v *ErrorType) Discriminant() ErrorTypeDiscriminant { return v.discriminant }

type ErrorTypeDiscriminant uint8

const (
	ErrorTypeNotFound      ErrorTypeDiscriminant = 0
	ErrorTypeUnauthorized  ErrorTypeDiscriminant = 1
	ErrorTypeAlreadyExists ErrorTypeDiscriminant = 2
	ErrorTypeUnknown       ErrorTypeDiscriminant = 3
)

func (v *ErrorType) String() string {
	switch v.discriminant {
	case ErrorTypeNotFound:
		return "not-found"
	case ErrorTypeUnauthorized:
		return "unauthorized"
	case ErrorTypeAlreadyExists:
		return "already-exists"
	case ErrorTypeUnknown:
		return "unknown"
	default:
		panic("invalid variant")
	}
}
func (v *ErrorType) GetNotFound() (ok bool) {
	if ok = (v.discriminant == ErrorTypeNotFound); !ok {
		return
	}
	return
}
func (v *ErrorType) SetNotFound() *ErrorType {
	v.discriminant = ErrorTypeNotFound
	v.payload = nil
	return v
}
func NewErrorTypeNotFound() *ErrorType {
	return (&ErrorType{}).SetNotFound()
}
func (v *ErrorType) GetUnauthorized() (ok bool) {
	if ok = (v.discriminant == ErrorTypeUnauthorized); !ok {
		return
	}
	return
}
func (v *ErrorType) SetUnauthorized() *ErrorType {
	v.discriminant = ErrorTypeUnauthorized
	v.payload = nil
	return v
}
func NewErrorTypeUnauthorized() *ErrorType {
	return (&ErrorType{}).SetUnauthorized()
}
func (v *ErrorType) GetAlreadyExists() (ok bool) {
	if ok = (v.discriminant == ErrorTypeAlreadyExists); !ok {
		return
	}
	return
}
func (v *ErrorType) SetAlreadyExists() *ErrorType {
	v.discriminant = ErrorTypeAlreadyExists
	v.payload = nil
	return v
}
func NewErrorTypeAlreadyExists() *ErrorType {
	return (&ErrorType{}).SetAlreadyExists()
}
func (v *ErrorType) GetUnknown() (ok bool) {
	if ok = (v.discriminant == ErrorTypeUnknown); !ok {
		return
	}
	return
}
func (v *ErrorType) SetUnknown() *ErrorType {
	v.discriminant = ErrorTypeUnknown
	v.payload = nil
	return v
}
func NewErrorTypeUnknown() *ErrorType {
	return (&ErrorType{}).SetUnknown()
}
func (v *ErrorType) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case ErrorTypeNotFound:
	case ErrorTypeUnauthorized:
	case ErrorTypeAlreadyExists:
	case ErrorTypeUnknown:
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

type Error struct {
	ErrorType *ErrorType
	Message   string
}

func (v *Error) String() string { return "Error" }

func (v *Error) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "error-type")
	write0, err := (v.ErrorType).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `error-type` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "message")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Message, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `message` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}
func (v *Error) Error() string { return v.String() }
